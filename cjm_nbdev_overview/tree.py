"""Generate tree visualizations for nbdev project structure"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_tree.ipynb.

# %% ../nbs/02_tree.ipynb 2
from __future__ import annotations
from pathlib import Path
from typing import List, Optional, Dict, Any
from nbdev.config import get_config
from .core import *
import re

# %% auto 0
__all__ = ['generate_tree_lines', 'generate_tree', 'extract_notebook_info', 'generate_tree_with_descriptions',
           'generate_subdirectory_tree', 'get_tree_summary']

# %% ../nbs/02_tree.ipynb 4
def generate_tree_lines(path: Path,                         # Directory to visualize
                       prefix: str = "",                    # Line prefix for tree structure
                       is_last: bool = True,                # Is this the last item in parent
                       show_notebooks_only: bool = False,   # Only show notebooks, not directories
                       max_depth: Optional[int] = None,     # Maximum depth to traverse
                       current_depth: int = 0               # Current depth in traversal
                       ) -> List[str]:                      # Lines of tree output
    "Generate tree visualization lines for a directory"
    lines = []
    
    # Skip if we've reached max depth
    if max_depth is not None and current_depth > max_depth:
        return lines
    
    # Get items to display
    items = []
    
    if not show_notebooks_only:
        # Get subdirectories
        subdirs = get_subdirectories(path, recursive=False)
        items.extend([(d, True) for d in subdirs])
    
    # Get notebooks in this directory
    notebooks = get_notebook_files(path, recursive=False)
    items.extend([(n, False) for n in notebooks])
    
    # Sort items by name
    items.sort(key=lambda x: x[0].name.lower())
    
    # Generate lines for each item
    for i, (item, is_dir) in enumerate(items):
        is_last_item = (i == len(items) - 1)
        
        # Determine the box drawing character
        if is_last_item:
            connector = "└── "
            extension = "    "
        else:
            connector = "├── "
            extension = "│   "
        
        # Add the item name
        lines.append(f"{prefix}{connector}{item.name}")
        
        # Recursively process directories
        if is_dir and not show_notebooks_only:
            child_prefix = prefix + extension
            child_lines = generate_tree_lines(
                item, child_prefix, is_last_item, 
                show_notebooks_only, max_depth, current_depth + 1
            )
            lines.extend(child_lines)
    
    return lines

# %% ../nbs/02_tree.ipynb 5
def generate_tree(path: Path = None,                    # Directory to visualize (defaults to nbs_path)
                 show_notebooks_only: bool = False,     # Only show notebooks, not directories
                 max_depth: Optional[int] = None        # Maximum depth to traverse
                 ) -> str:                              # Tree visualization as string
    "Generate a tree visualization for a directory"
    if path is None:
        cfg = get_config()
        path = cfg.nbs_path
    
    # Start with the root directory name
    lines = [f"{path.name}/"]
    
    # Generate tree lines
    tree_lines = generate_tree_lines(path, "", True, show_notebooks_only, max_depth)
    lines.extend(tree_lines)
    
    return '\n'.join(lines)

# %% ../nbs/02_tree.ipynb 9
def extract_notebook_info(path: Path                    # Path to notebook file
                         ) -> NotebookInfo:             # Notebook information
    "Extract title and description from a notebook"
    nb_info = NotebookInfo(
        path=path,
        name=path.stem
    )
    
    try:
        nb_content = read_notebook(path)
        cells = nb_content.get('cells', [])
        
        if not cells:
            return nb_info
        
        # Look for default_exp in first few code cells
        for cell in cells[:5]:
            if cell.get('cell_type') == 'code':
                source = get_cell_source(cell)
                if '#| default_exp' in source:
                    match = re.search(r'#\|\s*default_exp\s+(\S+)', source)
                    if match:
                        nb_info.export_module = match.group(1)
        
        # Extract title and description from first markdown cell
        for cell in cells:
            if cell.get('cell_type') == 'markdown':
                source = get_cell_source(cell)
                lines = source.strip().split('\n')
                
                if not lines:
                    continue
                
                # Look for H1 title
                for i, line in enumerate(lines):
                    if line.strip().startswith('# '):
                        nb_info.title = line.strip()[2:].strip()
                        
                        # Look for blockquote description after the title
                        # It could be on any subsequent line
                        for j in range(i + 1, len(lines)):
                            if lines[j].strip().startswith('> '):
                                nb_info.description = lines[j].strip()[2:].strip()
                                break
                            elif lines[j].strip() and not lines[j].strip().startswith('>'):
                                # If we hit a non-empty, non-blockquote line, stop looking
                                break
                        break
                
                # If we found a title, we're done
                if nb_info.title:
                    break
    
    except Exception:
        # If we can't read the notebook, just return basic info
        pass
    
    return nb_info

# %% ../nbs/02_tree.ipynb 12
def generate_tree_with_descriptions(path: Path = None,              # Directory to visualize
                                   show_counts: bool = True,        # Show notebook counts for directories
                                   max_depth: Optional[int] = None  # Maximum depth to traverse
                                   ) -> str:                        # Tree with descriptions
    "Generate tree visualization with descriptions from notebooks"
    if path is None:
        cfg = get_config()
        path = cfg.nbs_path
    
    lines = []
    
    # Check if this is a flat structure (no subdirectories)
    subdirs = get_subdirectories(path, recursive=False)
    is_flat = len(subdirs) == 0
    
    if is_flat:
        # Flat structure - show notebooks with descriptions
        lines.append(f"{path.name}/")
        notebooks = get_notebook_files(path, recursive=False)
        
        for i, nb_path in enumerate(notebooks):
            is_last = (i == len(notebooks) - 1)
            connector = "└── " if is_last else "├── "
            
            # Extract notebook info
            nb_info = extract_notebook_info(nb_path)
            
            # Format line with description
            if nb_info.description:
                line = f"{connector}{nb_path.name}".ljust(28) + f" # {nb_info.description}"
            else:
                line = f"{connector}{nb_path.name}"
            
            lines.append(line)
    else:
        # Nested structure - show directories with counts and descriptions
        lines.append(f"{path.name}/")
        lines.extend(_generate_nested_tree_lines(path, "", show_counts, max_depth))
    
    return '\n'.join(lines)

# %% ../nbs/02_tree.ipynb 13
def _generate_nested_tree_lines(path: Path,                         # Directory to process
                               prefix: str = "",                    # Line prefix
                               show_counts: bool = True,            # Show notebook counts
                               max_depth: Optional[int] = None,     # Maximum depth
                               current_depth: int = 0               # Current depth
                               ) -> List[str]:                      # Tree lines
    "Generate tree lines for nested directory structure"
    lines = []
    
    if max_depth is not None and current_depth >= max_depth:
        return lines
    
    # Get subdirectories
    subdirs = get_subdirectories(path, recursive=False)
    subdirs.sort(key=lambda x: x.name.lower())
    
    for i, subdir in enumerate(subdirs):
        is_last = (i == len(subdirs) - 1)
        connector = "└── " if is_last else "├── "
        extension = "    " if is_last else "│   "
        
        # Count notebooks in this directory (recursive)
        notebook_count = len(get_notebook_files(subdir, recursive=True))
        
        # Look for folder description from folder_name.ipynb
        folder_nb_path = subdir / f"{subdir.name}.ipynb"
        description = None
        if folder_nb_path.exists():
            nb_info = extract_notebook_info(folder_nb_path)
            description = nb_info.description
        
        # Format the line
        line_parts = [f"{prefix}{connector}{subdir.name}/"]
        
        if show_counts:
            count_str = f"{notebook_count} notebook{'s' if notebook_count != 1 else ''}"
            line_parts[0] = line_parts[0].ljust(28) + f" # {count_str}"
            
            if description:
                line_parts[0] += f" - {description}"
        elif description:
            line_parts[0] = line_parts[0].ljust(28) + f" # {description}"
        
        lines.append(line_parts[0])
        
        # Recursively process subdirectories
        if max_depth is None or current_depth + 1 < max_depth:
            child_lines = _generate_nested_tree_lines(
                subdir, prefix + extension, show_counts, 
                max_depth, current_depth + 1
            )
            lines.extend(child_lines)
    
    return lines

# %% ../nbs/02_tree.ipynb 17
def generate_subdirectory_tree(subdir_path: Path,               # Path to subdirectory
                              show_descriptions: bool = True    # Include notebook descriptions
                              ) -> str:                         # Tree visualization
    "Generate tree visualization for a specific subdirectory showing all notebooks"
    lines = [f"{subdir_path.name}/"]
    
    # Process all items (subdirs and notebooks) in order
    items = []
    
    # Get subdirectories
    subdirs = get_subdirectories(subdir_path, recursive=False)
    for subdir in subdirs:
        items.append((subdir, True))
    
    # Get notebooks
    notebooks = get_notebook_files(subdir_path, recursive=False)
    for notebook in notebooks:
        items.append((notebook, False))
    
    # Sort by name
    items.sort(key=lambda x: x[0].name.lower())
    
    # Generate tree lines
    for i, (item, is_dir) in enumerate(items):
        is_last = (i == len(items) - 1)
        lines.extend(_generate_subdirectory_lines(
            item, "", is_last, is_dir, show_descriptions, 0
        ))
    
    return '\n'.join(lines)

# %% ../nbs/02_tree.ipynb 18
def _generate_subdirectory_lines(item: Path,                    # Item to process
                                prefix: str,                    # Line prefix
                                is_last: bool,                  # Is last item
                                is_dir: bool,                   # Is directory
                                show_descriptions: bool,        # Show descriptions
                                depth: int                      # Current depth
                                ) -> List[str]:                 # Tree lines
    "Generate tree lines for subdirectory visualization"
    lines = []
    
    connector = "└── " if is_last else "├── "
    extension = "    " if is_last else "│   "
    
    if is_dir:
        # Directory entry
        line = f"{prefix}{connector}{item.name}/"
        lines.append(line)
        
        # Process subdirectory contents
        sub_items = []
        
        # Get nested subdirectories
        subdirs = get_subdirectories(item, recursive=False)
        for subdir in subdirs:
            sub_items.append((subdir, True))
        
        # Get notebooks in subdirectory
        notebooks = get_notebook_files(item, recursive=False)
        for notebook in notebooks:
            sub_items.append((notebook, False))
        
        # Sort by name
        sub_items.sort(key=lambda x: x[0].name.lower())
        
        # Generate lines for sub-items
        for j, (sub_item, sub_is_dir) in enumerate(sub_items):
            sub_is_last = (j == len(sub_items) - 1)
            lines.extend(_generate_subdirectory_lines(
                sub_item, prefix + extension, sub_is_last, 
                sub_is_dir, show_descriptions, depth + 1
            ))
    else:
        # Notebook entry
        if show_descriptions:
            nb_info = extract_notebook_info(item)
            if nb_info.description:
                line = f"{prefix}{connector}{item.name}".ljust(40) + f" # {nb_info.description}"
            else:
                line = f"{prefix}{connector}{item.name}"
        else:
            line = f"{prefix}{connector}{item.name}"
        
        lines.append(line)
    
    return lines

# %% ../nbs/02_tree.ipynb 20
def get_tree_summary(path: Path = None              # Directory to analyze
                    ) -> str:                       # Summary string
    "Get summary statistics for notebooks in directory tree"
    if path is None:
        cfg = get_config()
        path = cfg.nbs_path
    
    # Count notebooks
    total_notebooks = len(get_notebook_files(path, recursive=True))
    
    # Count directories
    subdirs = get_subdirectories(path, recursive=False)
    total_dirs = len(subdirs)
    
    if total_dirs == 0:
        return f"Total: {total_notebooks} notebook{'s' if total_notebooks != 1 else ''}"
    else:
        return f"Total: {total_notebooks} notebook{'s' if total_notebooks != 1 else ''} across {total_dirs} director{'ies' if total_dirs != 1 else 'y'}"
